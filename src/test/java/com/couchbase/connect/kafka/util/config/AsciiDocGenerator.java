/*
 * Copyright 2020 Couchbase, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.couchbase.connect.kafka.util.config;

import com.couchbase.connect.kafka.config.sink.CouchbaseSinkConfig;
import com.couchbase.connect.kafka.config.source.CouchbaseSourceConfig;
import com.google.common.io.Files;
import org.apache.kafka.common.config.ConfigDef;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import static java.nio.charset.StandardCharsets.UTF_8;
import static org.apache.kafka.common.config.ConfigDef.convertToString;

/**
 * Generates AsciiDoc suitable for inclusion in the source & sink config reference.
 */
public class AsciiDocGenerator {

  public static void main(String[] args) throws IOException {
    String docsRepo = System.getenv("KAFKAC_DOCS_REPO");
    if (docsRepo == null || docsRepo.isEmpty()) {
      throw new RuntimeException("Missing KAFKAC_DOCS_REPO environment variable. Please clone https://github.com/couchbase/docs-kafka and set that variable to the repository root directory.");
    }
    File docParent = new File(docsRepo, "modules/ROOT/pages");
    File sinkFile = new File(docParent, "generated-sink-config-reference.adoc");
    File sourceFile = new File(docParent, "generated-source-config-reference.adoc");

    if (!sinkFile.exists()) {
      throw new RuntimeException("Unexpected working directory; existing documentation not found: " + sinkFile);
    }
    if (!sourceFile.exists()) {
      throw new RuntimeException("Unexpected working directory; existing documentation not found: " + sinkFile);
    }

    String sinkDocs = generate(CouchbaseSinkConfig.class);
    String sourceDocs = generate(CouchbaseSourceConfig.class);

    Files.write(sinkDocs, sinkFile, UTF_8);
    Files.write(sourceDocs, sourceFile, UTF_8);

    System.out.println("Config reference documentation refreshed!");
  }

  private static String generate(Class<?> configClass) {
    ConfigDef config = ConfigHelper.define(configClass);
    StringWriter w = new StringWriter();
    PrintWriter out = new PrintWriter(w);
    out.println(":page-partial:");
    out.println();
    out.println("// This file was automatically generated by " + AsciiDocGenerator.class.getName());
    out.println();
    out.println(toAsciiDoc(config));
    return w.toString();
  }


  /**
   * This is a copy & paste of {@link ConfigDef#toEnrichedRst}, modified to
   * output AsciiDoc.
   */
  private static String toAsciiDoc(ConfigDef config) {
    StringBuilder b = new StringBuilder();

    String lastKeyGroupName = "";
    for (ConfigDef.ConfigKey key : sortedConfigs(config)) {
      if (key.internalConfig) {
        continue;
      }
      if (key.group != null) {
        if (!lastKeyGroupName.equalsIgnoreCase(key.group)) {
          b.append("== ").append(key.group).append("\n\n");
        }
        lastKeyGroupName = key.group;
      }

      getConfigKeyDoc(key, b);

      if (key.dependents != null && key.dependents.size() > 0) {
        int j = 0;
        b.append("* Dependents: ");
        for (String dependent : key.dependents) {
          b.append("`");
          b.append("<<").append(dependent).append(">>");
          if (++j == key.dependents.size()) {
            b.append("`");
          } else {
            b.append("`, ");
          }
        }
        b.append("\n");
      }
      b.append("\n");
    }
    return b.toString();

  }

  private static void getConfigKeyDoc(ConfigDef.ConfigKey key, StringBuilder b) {
    b.append("[[").append(key.name).append("]]\n");
    b.append("=== `").append(key.name).append("`").append("\n\n");
    for (String docLine : key.documentation.split("\n")) {
      if (docLine.isEmpty()) {
        continue;
      }
      b.append(docLine.replace(". ", ".\n")).append("\n\n");
    }
    b.append("* Type: ").append(getConfigValue(key, "Type")).append("\n");
    if (key.hasDefault()) {
      b.append("* Default: `").append(getConfigValue(key, "Default")).append("`\n");
    }
    if (key.validator != null) {
      b.append("* Valid Values: ").append(getConfigValue(key, "Valid Values")).append("\n");
    }
    b.append("* Importance: ").append(getConfigValue(key, "Importance")).append("\n");
  }

  protected static String getConfigValue(ConfigDef.ConfigKey key, String headerName) {
    switch (headerName) {
      case "Name":
        return key.name;
      case "Description":
        return key.documentation;
      case "Type":
        return key.type.toString().toLowerCase(Locale.ROOT);
      case "Default":
        if (key.hasDefault()) {
          if (key.defaultValue == null) {
            return "null";
          }
          String defaultValueStr = convertToString(key.defaultValue, key.type);
          if (defaultValueStr.isEmpty()) {
            return "\"\"";
          } else {
            return defaultValueStr;
          }
        } else {
          return "";
        }
      case "Valid Values":
        return key.validator != null ? key.validator.toString() : "";
      case "Importance":
        return key.importance.toString().toLowerCase(Locale.ROOT);
      default:
        throw new RuntimeException("Can't find value for header '" + headerName + "' in " + key.name);
    }
  }

  private static List<ConfigDef.ConfigKey> sortedConfigs(ConfigDef config) {
    final Map<String, Integer> groupOrd = new HashMap<>();
    int ord = 0;
    for (String group : config.groups()) {
      groupOrd.put(group, ord++);
    }

    List<ConfigDef.ConfigKey> configs = new ArrayList<>(config.configKeys().values());
    configs.sort((k1, k2) -> compare(k1, k2, groupOrd));
    return configs;
  }

  private static int compare(ConfigDef.ConfigKey k1, ConfigDef.ConfigKey k2, Map<String, Integer> groupOrd) {
    int cmp = k1.group == null
        ? (k2.group == null ? 0 : -1)
        : (k2.group == null ? 1 : Integer.compare(groupOrd.get(k1.group), groupOrd.get(k2.group)));
    if (cmp == 0) {
      cmp = Integer.compare(k1.orderInGroup, k2.orderInGroup);
      if (cmp == 0) {
        // first take anything with no default value
        if (!k1.hasDefault() && k2.hasDefault()) {
          cmp = -1;
        } else if (!k2.hasDefault() && k1.hasDefault()) {
          cmp = 1;
        } else {
          cmp = k1.importance.compareTo(k2.importance);
          if (cmp == 0) {
            return k1.name.compareTo(k2.name);
          }
        }
      }
    }
    return cmp;
  }
}
